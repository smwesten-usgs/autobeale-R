---
title: "Introduction to autobeale"
author: "Steve Westenbroek"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to autobeale}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview

This document demonstrates the basic use of the autobeale package. The code is broken into a number of discrete functions, which may be thought of as pertaining to either the Beale calculation itself, or else to the partitioning and stratification of the dataset *prior* to calculation with the Beale method.

## Background

The Beale Ratio Estimator has been used in numerous nutrient and pollutant loading studies, particularly for load estimates to the Great Lakes. The `autobeale` package traces its roots back earlier versions of software aimed at making these calculations easier. Peter Richards, the author of an earlier `AutoBeale` code has written about the 
evolution of Beale software over the years:

> The Beale Ratio Estimator is described in Tin (1965). It has been widely used for computation of
 substance loadings to receiving waters, particularly in the Great Lakes system. The initial code was
 developed by Ken Baun of Wisconsin DNR (1982). It was subsequently used and developed by Kevin McGunagle
 at the International Joint Commission (IJC), from whom the current version was received. It was then
 developed in the 1990’s by Pete Richards at the National Center for Water Quality Research
 at Heidelberg University (www.heidelberg.edu/academiclife/distinctive/ncwqr). Peter developed the code
 to work with the Macintosh computer of the time (“Motorola" architecture, which was replaced by
 Intel architecture ca. 2005), and included a Graphic User Interface (GUI) and an algorithm that 
 objectively and sequentially searched out the best stratification given the data, with “best” being defined as
 minimizing the root-mean-square error (RMSE) given the data at hand.

## Example dataset

This set of example applications demonstrates various approaches to estimation of nitrate-nitrite loads in kilograms in the Rocky River near Cleveland, Ohio. After loading the `autobeale` library as well as Hadly Wickham's excellent `dplyr` library, the data is read in from two simple tab-delimited text files. 


```{r, initialization, warning=FALSE,message=FALSE}

library(autobeale)
library(dplyr)
library(mcga)


```

The `autobeale::beale` function expects the incoming data to be provided in pairwise fashion. There should be a discharge value provided for *every* day within the timeframe for the laoding calculation, with a concentration value provided on days that were sampled. `dplyr::left_join` can be used to quickly create an input dataset suitable for use with the `beale` function.

```{r, results='asis'}

discharge_file     <- system.file( "extdata", "ROCKFLOW.DAT", package="autobeale")
concentration_file <- system.file( "extdata", "ROCKNO23.DAT", package="autobeale")

discharge_data     <- read.table( discharge_file, header=TRUE )
concentration_data <- read.table( concentration_file, header=TRUE )
qcdata <- dplyr::left_join(discharge_data, concentration_data, by=c("date" = "date") )

# don't forget to convert the discharge value to cubic meters per second!
qcdata$discharge <- cfs_to_cms( qcdata$discharge )

```

The resulting dataframe looks like this:

```{r, echo=FALSE, results='asis'}
knitr::kable(head(qcdata, 10))
```

## Example #1: load by means of the unstratified Beale ratio estimator

Note that the `beale` function expects discharge to be provided in units of *cubic meters per second*, with concentration data provided in units of *milligrams per liter*.

```{r, unstratified_beale, results='asis'}
result_list <- beale( discharge_cms=qcdata$discharge / 35.3146, conc_mg_L=qcdata$concentration )
print( result_list )
```

## Example #2: Beale Ratio Estimator with data partitioned into five stratums

In addition to the `beale` function are a number of `R6` classes aimed at making it easier to examine various data partitioning strategies. Strategies may be ranked by their impact on the root mean square of error associated with the load estimate. In this example, a genetic algorithm package is wired up to assist in the search for an optimum partitioning strategy, with optimimum being defined as minimization of the root mean square of error associated with the overall loading estimate, similar to the original AutoBeale.

In order to use these classes, real R date classes (POSIX) must be supplied along with the discharge and concentration data. Another of Hadley Wickham's library packages, `lubridate`, makes this easy:

```{r, date munging}

library(lubridate)

qcdata$date <- lubridate::ymd( qcdata$date )

```

The `qcdata` dataframe now looks like this:

```{r, echo=FALSE, results='asis'}
knitr::kable(head(qcdata, 10))
```

First we creata a `strata` object of the appropriate size (5 stratums):

```{r, strata and partitioning}
number_of_stratums <- 5
mystrata <- strata$new( number_of_stratums, qcdata )
```

Next we wire up a genetic algoritm package to test alternative partitioning strategies. Package `mcga` uses its `evalFunc` argument to pass a vector of fractions that define the partitioning scheme to the `strata` object, which evaluates the Beale load and returns the associated RMSE estimate.

The genetic algorithm package, in turn, compares the current RMSE value with other previously calculated values (associated with other partitioning strategies), and 'evolves' a new partitioning strategy to test. This process is repeated hundreds or thousands of times in an attempt to find a optimum partitioning strategy.

```{r, genetic_algorithm}

 m <- mcga( popsize=200,
            chsize=4,
            minval=0.0,
            maxval=1.0,
            elitism=10,
            maxiter=40,
            crossprob=1.0,
            mutateprob=0.05,
            evalFunc=mystrata$update_rmse )

 cat("Best chromosome:\n")
 cat(m$population[1,],"\n")
 cat("Cost: ",m$costs[1],"\n")

# create a copy of the strata object
best_strata <- mystrata$clone()

# rerun with the optimized parameter
best_strata$partitions$update( sort( m$population[ 1, ]) )
best_strata$rearrange_stratums( best_strata$partitions$get_date_values() )

best_strata$calc_loads()
results_df <- best_strata$summarize_results()

# round values to produce a more readable table
results_df <- data.frame(lapply(results_df, function(y) if(is.numeric(y)) round(y, 2) else y)) 
```

The results of the load calculation with optimum stratification using 5 stratums now looks like this:

```{r, echo=FALSE, results='asis'}
knitr::kable( results_df, digits=2 )
```

## Original AutoBeale results for the same data file

For reference, here are the summarized results generated by Peter Richard's original AutoBeale code:

    Stratification applied:

    block  stratum   start      end   

    1       1     19970101 19970420
    2       2     19970421 19970526
    3       3     19970527 19970817
    4       4     19970818 19971201
    5       5     19971202 19971231


    Summary over 5 strata:
    
    Mean daily loading:      
                             459187.6  g/day
                          167603487.   g/year
                             167603.4  kg/year

    Mean square error:   893200710.529 ( g/day)**2
                         118996664.660 (kg/year)**2

    based on     9.348 degrees of freedom
    The 95% confidence interval half-width is       24539.3375 kg/year
